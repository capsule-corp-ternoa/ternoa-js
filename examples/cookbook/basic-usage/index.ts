import '@polkadot/api-augment';
import { MarketplaceKind, WaitUntil } from '../../../src/constants';
import { NFTCreatedEvent, NFTListedEvent } from '../../../src/events';

import { getKeyringFromSeed } from '../../../src/account/index';
import { createCollection, createNftTx } from '../../../src/nft/index';
import { batchAllTxHex, initializeApi, signTx, submitTxBlocking } from '../../../src/blockchain/index';
import { buyNft, createMarketplace, listNftTx, setMarketplaceKind, setMarketplaceOwner } from '../../../src/marketplace';


async function main() {
    // This will initialize the internal SDK API.
    //
    // It's not strictly necessary but it's good practice to initialize the API as soon as possible.
    // This call can be omitted but then in the first SDK call the API will be forcefully initialized.
    // You can also specify the endpoint by passing the endpoint address as the first argument.
    await initializeApi();

    // This will create a keyring from the provided account seed.
    //
    // Activities and communication on the blockchain is achieved through executing extrinsics (also called transactions). In 
    // order to execute them someone needs to sign them and pay the execution fee. That someone is in this case you and you
    // are represented through a concept called Keyring.
    // Here we provide a default account that you can use to do this exercise. In case you want to use your own account you
    // need to change //TernoaTestAccount with your account seed.
    const keyring = await getKeyringFromSeed("//TernoaTestAccount");

    // Here we define the metadata about our collection.
    //
    // Collection metadata is additional data that is stored off-chain (which means it's not stored on the chain) and it's
    // used to better describe the collection itself. In most cases this will be an IPFS hash that points to a JSON file
    // which contains fields as "name", "description" or "image". In other cases this can be a link to a either a static
    // or a dynamic file, plain text or a small JSON string.
    //
    // In this exercise we will not use IPFS and instead we will just use this metadata to store our collection name.
    // It's called offchainData since it usually point to collection data that is stored off-chain.
    const collectionOffchainData = "Bored Dog Yacht Club (BDYC)";

    // Here we define how much NFTs will be stored inside our collection.
    //
    // Our goal is to make an exclusive collection just for a few VIP members so we will limit it to max 10 NFTs. This
    // can of course be set to undefined instead of 10 and in this case the collection will be open ended. In case
    // that you start with an open ended collection you can at any point limit it later.
    const limit = 10;

    // Here we define at which point we want to get the results of the transaction execution.
    //
    // There are two points for now. Either we get the results when the transaction is included in the block (BlockInclusion)
    // or when the transaction is included in the block and that block is also finalized (BlockFinalization).
    // In general BlockInclusion is faster (done under 6 seconds) while BlockFinalization usually takes around 18 seconds.
    // In case that those two modes are not clear enough, there is a chapter that explains the differences in more details
    // but the general rule of thumb is to use BlockInclusion until the code needs to be used in the production where you
    // would usually switch to BlockFinalization.
    const executionTrigger = WaitUntil.BlockInclusion;

    // Here we use our predefined data in order to create our collection.
    //
    // This is one of the many convenient function that are available in our SDK. This function will create a
    // "createCollection" extrinsic, it will sign it with our keyring and it will execute it. It was also wait
    // until the execution has been finished and as a result it will return the CollectionCreatedEvent event which
    // was generated by the chain. 
    //
    // Contrary to using the raw Polkadot JS API, here you don't need to do any of those steps manually. Everything
    // is automatically handled which substantially decreases the amount of code that you need write. As a 
    // reference, it would take more than 30 lines of code to do this by just using the raw Polkadot JS API.
    const collectionEvent = await createCollection(collectionOffchainData, limit, keyring, executionTrigger);

    // Here we print out the event that we got from creating a collection. This is just for debug purposes.
    console.log(collectionEvent);

    //
    // That's it for Collection. The first step is done and we got our own collection locked and loaded. Now we need to 
    // to add some NFTs to it so that it becomes more useful.
    //

    // Here we define the name of the dogs that we will use.
    //
    // The first step in creating our Dog NFTs we to define how they will be called. To make sure that no bias
    // is being shown, this list contains the names of the most popular dog names in the USA. Feel free to 
    // replace the names with something that you are more conformable with :) 
    const dogNames = ["Charlie", "Bella", "Max", "Luna", "Buddy", "Coco", "Milo", "Ruby", "Archie", "Molly"];

    // Here we define the royalty of our NFTs.
    //
    // The plan is to created our dog NFTs and to list them for sale. Selling them is just one way to get 
    // value of them. By setting the royalty to a value over 0 means that we will get a cut of every next sale
    // that will be done with our NFTs. The range is [0, 100] and decimal numbers can be used.
    // Example: setting it to 10 means that after the initial sale we will receive 10% of all secondary sales.
    const royalty = 10;

    // Here we create one createNftTx for each dog name.
    //
    // This process is a bit different that the one before. We could have done the same and create all the NFTs one by one
    // but it's recommended that in cases where more than one operation is needs to be done to group them all and  to executed them
    // as one transaction. This allows us to save on transaction fees and most importantly to save on time. In the best case
    // scenario doing one by one would take us 1 minute to do for 10 dogs but with this it will take us less than 6 seconds.
    //
    // Here just like with collection, instead of providing an IPFS link for the NFT offchaindata we will pass the name of the dog instead.
    // For collectionId we use the one that we have created in the previous step.
    // It's important to know that besides the transaction fees the signer also pays additional NFT Mint fee for every minted NFT.
    // What this actually is and how to handle it is explained in more details in another exercise.
    const signableNFTTxs = await Promise.all(dogNames.map(name => createNftTx(name, royalty, collectionEvent.collectionId, false)));

    // Here we batch (group) all those created transaction into one transaction
    //
    // There are two transactions that do the same, one is called batch and the second one is called batchAll.
    // The difference is that with just "batch" that our transactions will be executed until one fails and at
    // that point it will not continue to the next batched transaction. With "batchAll" it will try to first
    // do them all and if any one fails it will revered the successful ones and the state of the chain will not
    // change.
    // The general rule of thumb is to always use the batchAll transaction.
    const signableNFTBatchTx = await batchAllTxHex(signableNFTTxs);

    // Here we submit (and sign) our batch transaction.
    //
    // You probably have noticed that instead of creating NFTs we are actually creating NFT transactions. 
    // We do this so that we could group them all together. The downside is that we need to manually sign them
    // and submit them (submitting means executing). To make the whole process super convenient and flexible, 
    // we provide three different submitting functions. Here, we use the most convenient one but it's the least
    // flexible. This function will sign the transaction for us if we pass a keyring (one less thing to worry about)
    // and it's blocking the execution flow until the transaction is either in a block or in a finalized block.
    // Since submitting needs to work will all kinds of transactions, the result is an object that contains all
    // the events that have happen (instead of only specific ones). 
    const allEvents = await submitTxBlocking(signableNFTBatchTx, WaitUntil.BlockInclusion, keyring);

    // Here we get only the events that we are interested in.
    //
    // Since submitTxBlocking returned all the events that have happen we want to get only the ones that are
    // important to us. In this case, we are looking for NFTCreatedEvents and here is another nice example
    // how our API is quite convenient. Instead of manually searching our events of interest we can just
    // call the findEvents call and pass the type of the event that we are looking for. The result of this
    // function will be a list of those events and they will have the same type that we are expecting.
    const dogs = allEvents.findEvents(NFTCreatedEvent);

    // Here we print out the events that we got from creating our dog NFTs. This is just for debug purposes.
    dogs.forEach(dog => console.log(dog));

    //
    // That's it for our doggo NFTs. The second step is done and we have created our NFTs and assigned them to our
    // step 1 collection. In the next step we will create a marketplace for them to be sold.
    //

    // Here we define the type (kind) of the marketplace.
    //
    // Our blockchain can differentiate between two types of marketplaces: Public ones and Private ones. 
    // On Public marketplaces anyone can list their NFTs and anyone can buy them.
    // On Private marketplaces only certain people are allowed ot list their NFTs and anyone can buy them. 
    //
    // There are a lot more functionality that comes with our marketplaces (like the commission or listing fee)
    // but for the sake of simplicity we will ignore this aspect and just create a simple plain Public marketplace.
    const kind = MarketplaceKind.Public;

    // Here we create our marketplace.
    //
    // Only the "kind" predefined data is needed in order to create a marketplace. It's important to mention
    // that creating a marketplace it's cheap and currently besides the transaction fees it the signer also
    // needs to pay an additional Marketplace Mint fee. What this actually is and how to handle it is explained 
    // in more details in another exercise.
    const marketplaceEvent = await createMarketplace(kind, keyring, WaitUntil.BlockInclusion);

    //
    // That's it for creating a Marketplace. Literally we needed two lines for it (it can also be done in one :P)
    // In the next step we will list all our nfts for sale on our newly created marketplace.
    //

    // Here we define the price of our NFTs.
    //
    // There are two ways in how we can define the price. 
    // If a "number" is used then 100 would mean that the price of each NFT will be 100 CAPS. 
    // if a "BN" is used then we would have needed to create a BN object with the following literal
    // "100000000000000000000" to get the same result. It's currently not really visible on why
    // you would use the second notation but there are reasons for it and they are covered in details
    // in another exercise.
    // For the sake of simplicity and convenience we will use a "number".
    const price: number = 100;

    // Here we create one listNftTx for each dog NFT.
    //
    // To list an NFT for sale only three inputs are needed. The NFT ID, the Marketplace ID and the price of the
    // NFT. It's important to pick the right marketplace to list our NFTs because some marketplaces might be
    // popular and heavily used but they could have high listing or commission fees. In this case we use our own
    // marketplace to list our NFTs so no additional hidden fees will occur.
    const signableListTxs = await Promise.all(dogs.map(dog => listNftTx(dog.nftId, marketplaceEvent.marketplaceId, price)));

    // Here we batch (group) all those created transaction into one transaction,
    //
    // It's the same story as before. We group all our transactions so that instead of calling them one by one we just need
    // to do it once.
    const signableListBatchTx = await batchAllTxHex(signableListTxs);

    // Here we sign the batch transaction.
    //
    // This is not mandatory since the submitTxBlocking can do this for us but it's good to know how to do it manually.
    const signedListBatchTx = await signTx(keyring, signableListBatchTx);

    // Here we submit our batch transaction.
    //
    // Now we don't need to pass our keyring since we have signed the transaction in the previous step.
    //
    // Events that are always there are the ExtrinsicSuccessEvent or ExtrinsicFailedEvent event which can tell
    // us if our transaction was either successful or it failed. If batching is used (we use it here) the following
    // events can also available: ItemCompletedEvent, BatchInterruptedEvent, or BatchCompletedEvent.
    const allEvents2 = await submitTxBlocking(signedListBatchTx, WaitUntil.BlockInclusion);

    // Here we get only the events that we are interested in.
    //
    // If not event is found it would mean that either we are looking for the wrong event or 
    // something went wrong.
    const listedDogs = allEvents2.findEvents(NFTListedEvent);

    // Here we print out the events that we got from listing our dog NFTs for sale. This is just for debug purposes.
    listedDogs.forEach(listedDog => console.log(listedDog));

    //
    // That's it for listing our dog NFTs for sale.
    // In the next and final step we will buy one of our NFTs :)
    //

    // This will create a keyring from the provided account seed.
    //
    // To buy one of our NFTs we need to use a second account for this.
    const keyring2 = await getKeyringFromSeed("//TernoaTestAccount2");

    // Here we buy one of our NFTs with the second account.
    //
    // The second account provided in the previous is going to be used to buy the first
    // NFT that was listed. 
    let buyNftEvent = await buyNft(listedDogs[0].nftId, keyring2, WaitUntil.BlockInclusion);

    // Here we print out the event that we got from buying our own dog NFT. This is just for debug purposes.
    console.log(buyNftEvent);

    //
    // That's all. We have successfully ended our long journey started from creating a collection, then
    // creating our beloved doggo NFTs, creating our own marketplace, listing our NFTs and in the end we
    // even bought our own NFT. With this you should have a basic understanding on how to use the SDK
    // in the most simplest way. The SDK itself has more functions and can provide more flexibility 
    // but this is explored in other exercises.
    //


    process.exit();
}

main();

