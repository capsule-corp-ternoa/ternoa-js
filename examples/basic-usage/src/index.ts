import {
  NFTCreatedEvent,
  NFTListedEvent,
  batchAllTxHex,
  initializeApi,
  signTxHex,
  submitTxBlocking,
  safeDisconnect,
} from "ternoa-js"

import { createCollection, createNftTx } from "ternoa-js/nft/index.js"
import { buyNft, createMarketplace, listNftTx } from "ternoa-js/marketplace/index.js"
import { MarketplaceKind } from "ternoa-js/marketplace/enum.js"

import { getKeyringFromSeed } from "ternoa-js/account/index.js"
import { WaitUntil } from "ternoa-js/constants.js"

async function main() {
  // This will initialize the internal SDK API.
  //
  // It's not strictly necessary but it's good practice to initialize the API as soon as possible.
  // If this call is omitted then the first SDK call will return an exception.
  // You can also specify the endpoint by passing the endpoint address as the first argument.
  await initializeApi()

  // This will create a keyring from the provided account seed.
  //
  // Activities and communication on the blockchain is achieved through executing extrinsics (also called transactions). In
  // order to execute them someone needs to sign them and pay the execution fee. That someone is in this case you and you
  // are represented through a concept called Keyring.
  // Here we provide a default account that you can use to do this exercise. In case you want to use your own account you
  // need to change //TernoaTestAccount with your account seed.
  const keyring = await getKeyringFromSeed("//TernoaTestAccount")

  // Here we define the metadata about our collection.
  //
  // Collection metadata is additional data that is stored off-chain (which means it's not stored on the chain) and it's
  // used to better describe the collection itself. In most cases this will be an IPFS hash that points to a JSON file
  // which contains fields as "name", "description" or "image". In other cases this can be a link to a either a static
  // or a dynamic file, plain text or a small JSON string.
  //
  // In this exercise we will not use IPFS and instead we will just use this metadata to store our collection name.
  // It's called offchainData since it usually point to collection data that is stored off-chain.
  const collectionOffchainData = "Bored Dog Yacht Club (BDYC)"

  // Here we define how much NFTs will be stored inside our collection.
  //
  // Our goal is to make an exclusive collection just for a few VIP members so we will limit it to max 10 NFTs. This
  // can of course be set to undefined instead of 10 and in this case the collection will be open ended. In case
  // that you start with an open ended collection you can at any point limit it later.
  const limit = 10

  // Here we define at which point we want to get the results of the transaction execution.
  //
  // There are two points for now. Either we get the results when the transaction is included in the block (BlockInclusion)
  // or when the transaction is included in the block and that block is also finalized (BlockFinalization).
  // In general BlockInclusion is faster (done under 6 seconds) while BlockFinalization usually takes around 18 seconds.
  // In case that those two modes are not clear enough, there is a chapter that explains the differences in more details
  // but the general rule of thumb is to use BlockInclusion until the code needs to be used in the production where you
  // would usually switch to BlockFinalization.
  const executionTrigger = WaitUntil.BlockInclusion

  // Here we use our predefined data in order to create our collection.
  //
  // This is one of the many convenient function that are available in our SDK. This function will create a
  // "createCollection" extrinsic, it will sign it with our keyring and it will execute it. It was also wait
  // until the execution has been finished and as a result it will return the CollectionCreatedEvent event which
  // was generated by the chain.
  //
  // Contrary to using the raw Polkadot JS API, here you don't need to do any of those steps manually. Everything
  // is automatically handled which substantially decreases the amount of code that you need write. As a
  // reference, it would take more than 30 lines of code to do this by just using the raw Polkadot JS API.
  const collectionEvent = await createCollection(collectionOffchainData, limit, keyring, executionTrigger)

  // Here we print out the event that we got from creating a collection. This is just for debug purposes.
  console.log(collectionEvent)

  //
  // That's it for Collection. The first step is done and we got our own collection locked and loaded. Now we need
  // to add some NFTs to it so that it becomes more useful.
  //

  // Here we define the name of the dogs that we will use.
  //
  // The first step in creating our Dog NFTs we to define how they will be called. To make sure that no bias
  // is being shown, this list contains the names of the most popular dog names in the USA. Feel free to
  // replace the names with something that you are more conformable with :)
  const dogNames = ["Charlie", "Bella", "Max", "Luna", "Buddy", "Coco", "Milo", "Ruby", "Archie", "Molly"]

  // Here we define the royalty of our NFTs.
  //
  // The plan is to created our dog NFTs and to list them for sale. Selling them is just one way to get
  // value of them. By setting the royalty to a value over 0 means that we will get a cut of every next sale
  // that will be done with our NFTs. The range is [0, 100] and decimal numbers can be used.
  // Example: setting it to 10 means that after the initial sale we will receive 10% of all secondary sales.
  const royalty = 10

  // Here we create one createNftTx for each dog name.
  //
  // This process is a bit different that the one before. We could have done the same and create all the NFTs one by one
  // but it's recommended that in cases where more than one operation is needs to be done to group them all and  to executed them
  // as one transaction. This allows us to save on transaction fees and most importantly to save on time. In the best case
  // scenario doing one by one would take us 1 minute to do for 10 dogs but with this it will take us less than 6 seconds.
  //
  // Here just like with collection, instead of providing an IPFS link for the NFT offchaindata we will pass the name of the dog instead.
  // For collectionId we use the one that we have created in the previous step.
  // It's important to know that besides the transaction fees the signer also pays additional NFT Mint fee for every minted NFT.
  // What this actually is and how to handle it is explained in more details in another exercise.
  const signableNFTTxs = await Promise.all(
    dogNames.map((name) => createNftTx(name, royalty, collectionEvent.collectionId, false)),
  )

  // Here we batch (group) all those created transaction into one transaction
  //
  // There are two transactions that do the same, one is called batch and the second one is called batchAll.
  // The difference is that with just "batch" that our transactions will be executed until one fails and at
  // that point it will not continue to the next batched transaction. With "batchAll" it will try to first
  // do them all and if any one fails it will revered the successful ones and the state of the chain will not
  // change.
  // The general rule of thumb is to always use the batchAll transaction.
  const signableNFTBatchTx = await batchAllTxHex(signableNFTTxs)

  // Here we submit (and sign) our batch transaction.
  //
  // You probably have noticed that instead of creating NFTs we are actually creating NFT transactions.
  // We do this so that we could group them all together. The downside is that we need to manually sign them
  // and submit them (submitting means executing). To make the whole process super convenient and flexible,
  // we provide three different submitting functions. Here, we use the most convenient one but it's the least
  // flexible. This function will sign the transaction for us if we pass a keyring (one less thing to worry about)
  // and it's blocking the execution flow until the transaction is either in a block or in a finalized block.
  // Since submitting needs to work will all kinds of transactions, the result is an object that contains all
  // the events that have happen (instead of only specific ones).
  const allEvents = await submitTxBlocking(signableNFTBatchTx, WaitUntil.BlockInclusion, keyring)

  // Here we get only the events that we are interested in.
  //
  // Since submitTxBlocking returned all the events that have happen we want to get only the ones that are
  // important to us. In this case, we are looking for NFTCreatedEvents and here is another nice example
  // how our API is quite convenient. Instead of manually searching our events of interest we can just
  // call the findEvents call and pass the type of the event that we are looking for. The result of this
  // function will be a list of those events and they will have the same type that we are expecting.
  const dogs = allEvents.events.findEvents(NFTCreatedEvent)

  // Here we print out the events that we got from creating our dog NFTs. This is just for debug purposes.
  dogs.forEach((dog) => console.log(dog))

  //
  // That's it for our doggo NFTs. The second step is done and we have created our NFTs and assigned them to our
  // step 1 collection. In the next step we will create a marketplace for them to be sold.
  //

  // Here we define the type (kind) of the marketplace.
  //
  // Our blockchain can differentiate between two types of marketplaces: Public ones and Private ones.
  // On Public marketplaces anyone can list their NFTs and anyone can buy them.
  // On Private marketplaces only certain people are allowed ot list their NFTs and anyone can buy them.
  //
  // There are a lot more functionality that comes with our marketplaces (like the commission or listing fee)
  // but for the sake of simplicity we will ignore this aspect and just create a simple plain Public marketplace.
  const kind = MarketplaceKind.Public

  // Here we create our marketplace.
  //
  // Only the "kind" predefined data is needed in order to create a marketplace. It's important to mention
  // that creating a marketplace it's cheap and currently besides the transaction fees it the signer also
  // needs to pay an additional Marketplace Mint fee. What this actually is and how to handle it is explained
  // in more details in another exercise.
  const marketplaceEvent = await createMarketplace(kind, keyring, WaitUntil.BlockInclusion)

  //
  // That's it for creating a Marketplace. Literally we needed two lines for it (it can also be done in one :P)
  // In the next step we will list all our nfts for sale on our newly created marketplace.
  //

  // Here we define the price of our NFTs.
  //
  // There are two ways in how we can define the price.
  // If a "number" is used then 100 would mean that the price of each NFT will be 100 CAPS.
  // if a "BN" is used then we would have needed to create a BN object with the following literal
  // "100000000000000000000" to get the same result. It's currently not really visible on why
  // you would use the second notation but there are reasons for it and they are covered in details
  // in another exercise.
  // For the sake of simplicity and convenience we will use a "number".
  const price = 100

  // Here we create one listNftTx for each dog NFT.
  //
  // To list an NFT for sale only three inputs are needed. The NFT ID, the Marketplace ID and the price of the
  // NFT. It's important to pick the right marketplace to list our NFTs because some marketplaces might be
  // popular and heavily used but they could have high listing or commission fees. In this case we use our own
  // marketplace to list our NFTs so no additional hidden fees will occur.
  const signableListTxs = await Promise.all(
    dogs.map((dog) => listNftTx(dog.nftId, marketplaceEvent.marketplaceId, price)),
  )

  // Here we batch (group) all those created transaction into one transaction,
  //
  // It's the same story as before. We group all our transactions so that instead of calling them one by one we just need
  // to do it once.
  const signableListBatchTx = await batchAllTxHex(signableListTxs)

  // Here we sign the batch transaction.
  //
  // This is not mandatory since the submitTxBlocking can do this for us but it's good to know how to do it manually.
  const signedListBatchTx = await signTxHex(keyring, signableListBatchTx)

  // Here we submit our batch transaction.
  //
  // Now we don't need to pass our keyring since we have signed the transaction in the previous step.
  //
  // Events that are always there are the ExtrinsicSuccessEvent or ExtrinsicFailedEvent event which can tell
  // us if our transaction was either successful or it failed. If batching is used (we use it here) the following
  // events can also available: ItemCompletedEvent, BatchInterruptedEvent, or BatchCompletedEvent.
  const allEvents2 = await submitTxBlocking(signedListBatchTx, WaitUntil.BlockInclusion)

  // Here we get only the events that we are interested in.
  //
  // If not event is found it would mean that either we are looking for the wrong event or
  // something went wrong.
  const listedDogs = allEvents2.events.findEvents(NFTListedEvent)

  // Here we print out the events that we got from listing our dog NFTs for sale. This is just for debug purposes.
  listedDogs.forEach((listedDog) => console.log(listedDog))

  if (listedDogs[0] == undefined) {
    throw new Error("Something went wrong.")
  }

  //
  // That's it for listing our dog NFTs for sale.
  // In the next and final step we will buy one of our NFTs :)
  //

  // This will create a keyring from the provided account seed.
  //
  // To buy one of our NFTs we need to use a second account for this.
  const keyring2 = await getKeyringFromSeed("//TernoaTestAccount2")

  // Here we buy one of our NFTs with the second account.
  //
  // The second account provided in the previous step is going to be used to buy the first
  // NFT that was listed with our original account.
  const buyNftEvent = await buyNft(listedDogs[0].nftId, keyring2, WaitUntil.BlockInclusion)

  // Here we print out the event that we got from buying our own dog NFT. This is just for debug purposes.
  console.log(buyNftEvent)

  //
  // That's all. We have successfully ended our long journey started from creating a collection, then
  // creating our beloved doggo NFTs, creating our own marketplace, listing our NFTs and in the end we
  // even bought our own NFT. With this you should have a basic understanding on how to use the SDK
  // in the most simplest way. The SDK itself has more functions and can provide more flexibility
  // but this is explored in other exercises.
  //

  await safeDisconnect()

  process.exit()
}

main()
